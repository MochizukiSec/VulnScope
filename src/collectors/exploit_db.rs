use crate::models::*;
use super::VulnerabilityCollector;
use reqwest::Client;
use serde::Deserialize;
use chrono::Utc;
use uuid::Uuid;

pub struct ExploitDbCollector {
    client: Client,
}

#[derive(Debug, Deserialize)]
struct ExploitDbEntry {
    id: String,
    description: String,
    date_published: String,
    author: String,
    platform: String,
    #[serde(rename = "type")]
    exploit_type: String,
    port: Option<u16>,
    tags: Vec<String>,
    verified: bool,
}

impl ExploitDbCollector {
    pub fn new() -> Self {
        Self {
            client: Client::new(),
        }
    }

    fn parse_cve_from_description(&self, description: &str) -> Option<String> {
        // Simple regex to find CVE IDs in description
        if let Ok(re) = regex::Regex::new(r"CVE-\d{4}-\d{4,}") {
            if let Some(mat) = re.find(description) {
                return Some(mat.as_str().to_string());
            }
        }
        None
    }

    fn determine_severity(&self, exploit_type: &str, verified: bool) -> Severity {
        match exploit_type.to_lowercase().as_str() {
            "remote" if verified => Severity::High,
            "remote" => Severity::Medium,
            "local" if verified => Severity::Medium,
            "local" => Severity::Low,
            "webapps" if verified => Severity::High,
            "webapps" => Severity::Medium,
            "dos" => Severity::Low,
            _ => Severity::Medium,
        }
    }
}

#[async_trait::async_trait]
impl VulnerabilityCollector for ExploitDbCollector {
    async fn collect(&self) -> anyhow::Result<Vec<Vulnerability>> {
        let mut vulnerabilities = Vec::new();
        
        // Exploit-DB doesn't have a direct API, so we'll use their CSV dump
        // In a real implementation, you might parse their CSV or use web scraping
        tracing::info!("Fetching exploits from Exploit-DB");
        
        // For demo purposes, we'll create some sample exploit-based vulnerabilities
        let sample_exploits = vec![
            ExploitDbEntry {
                id: "50001".to_string(),
                description: "Apache HTTP Server 2.4.49 - Path Traversal Remote Code Execution (CVE-2021-41773)".to_string(),
                date_published: "2021-10-05".to_string(),
                author: "John Doe".to_string(),
                platform: "linux".to_string(),
                exploit_type: "remote".to_string(),
                port: Some(80),
                tags: vec!["apache".to_string(), "rce".to_string()],
                verified: true,
            },
            ExploitDbEntry {
                id: "50002".to_string(),
                description: "WordPress Core < 5.8.2 - Authenticated Arbitrary File Deletion (CVE-2021-24537)".to_string(),
                date_published: "2021-09-15".to_string(),
                author: "Security Researcher".to_string(),
                platform: "php".to_string(),
                exploit_type: "webapps".to_string(),
                port: Some(80),
                tags: vec!["wordpress".to_string(), "file-deletion".to_string()],
                verified: true,
            },
        ];

        for exploit in sample_exploits {
            let cve_id = self.parse_cve_from_description(&exploit.description);
            let severity = self.determine_severity(&exploit.exploit_type, exploit.verified);
            
            // Parse date
            let published_date = if let Ok(naive_date) = chrono::NaiveDate::parse_from_str(&exploit.date_published, "%Y-%m-%d") {
                naive_date.and_hms_opt(0, 0, 0).unwrap().and_utc()
            } else {
                Utc::now()
            };

            let vulnerability = Vulnerability {
                id: Uuid::new_v4(),
                cve_id,
                title: exploit.description.clone(),
                description: format!(
                    "Exploit available for {}. Platform: {}, Type: {}, Verified: {}",
                    exploit.description, exploit.platform, exploit.exploit_type, exploit.verified
                ),
                severity,
                cvss_score: None,
                cvss_vector: None,
                cwe_id: None,
                affected_products: vec![exploit.platform.clone()],
                references: vec![format!("https://www.exploit-db.com/exploits/{}", exploit.id)],
                exploits: vec![format!("https://www.exploit-db.com/exploits/{}", exploit.id)],
                patches: Vec::new(),
                source: "Exploit-DB".to_string(),
                source_url: Some(format!("https://www.exploit-db.com/exploits/{}", exploit.id)),
                published_date,
                modified_date: published_date,
                created_at: Utc::now(),
                updated_at: Utc::now(),
                tags: {
                    let mut tags = exploit.tags;
                    tags.push("exploit-db".to_string());
                    tags.push("exploit".to_string());
                    tags
                },
                status: VulnStatus::New,
            };

            vulnerabilities.push(vulnerability);
        }

        tracing::info!("Collected {} exploits from Exploit-DB", vulnerabilities.len());
        Ok(vulnerabilities)
    }

    fn name(&self) -> &str {
        "Exploit-DB"
    }

    fn description(&self) -> &str {
        "Exploit Database - Archive of public exploits and corresponding vulnerable software"
    }
} 